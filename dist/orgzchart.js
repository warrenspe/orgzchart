/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/orgzchart.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/finally.js":
/*!******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/finally.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (callback) {\n  var constructor = this.constructor;\n  return this.then(function (value) {\n    return constructor.resolve(callback()).then(function () {\n      return value;\n    });\n  }, function (reason) {\n    return constructor.resolve(callback()).then(function () {\n      return constructor.reject(reason);\n    });\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/finally.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/src/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _finally = __webpack_require__(/*! ./finally */ \"./node_modules/promise-polyfill/src/finally.js\");\n\nvar _finally2 = _interopRequireDefault(_finally);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function () {\n    fn.apply(thisArg, arguments);\n  };\n}\n\nfunction Promise(fn) {\n  if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function () {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n    if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function () {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return;\n      done = true;\n      resolve(self, value);\n    }, function (reason) {\n      if (done) return;\n      done = true;\n      reject(self, reason);\n    });\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = _finally2.default;\n\nPromise.all = function (arr) {\n  return new Promise(function (resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(val, function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.resolve = function (value) {\n  if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function (resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn = typeof setImmediate === 'function' && function (fn) {\n  setImmediate(fn);\n} || function (fn) {\n  setTimeoutFunc(fn, 0);\n};\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\nexports.default = Promise;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/index.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/polyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/polyfill.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _index = __webpack_require__(/*! ./index */ \"./node_modules/promise-polyfill/src/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _finally = __webpack_require__(/*! ./finally */ \"./node_modules/promise-polyfill/src/finally.js\");\n\nvar _finally2 = _interopRequireDefault(_finally);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar globalNS = function () {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n}();\n\nif (!globalNS.Promise) {\n  globalNS.Promise = _index2.default;\n} else if (!globalNS.Promise.prototype['finally']) {\n  globalNS.Promise.prototype['finally'] = _finally2.default;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/polyfill.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\n(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            process.nextTick(function () {\n                runIfPresent(handle);\n            });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function registerImmediate(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function registerImmediate(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function registerImmediate(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? undefined : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || undefined && undefined.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || undefined && undefined.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/data_convert.js":
/*!*****************************!*\
  !*** ./src/data_convert.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*  Accepts all supported formats of data, and converts them into format 1 (Nested Objects).\n    See orgzchart.js for more information regarding accepted input types.\n\n    Inputs: data   - The object/string/array/etc containing the data to convert to nested object form.\n            config - Configuration to use while parsing the input data\n\n    Outputs: A promise which resolves when the data has been converted.\n*/\nfunction convertData(data, config) {\n    switch (data.constructor) {\n        case String:\n            return convertString(data, config);\n\n        case Array:\n            return convertArray(data, config);\n\n        case Object:\n            return convertObject(data, config);\n\n        default:\n            return new Promise.reject(\"Unknown data input type.\");\n    }\n}\n\n/*  Fetches the data via AJAX, then passes it to the convert function to ensure it is returned in the correct format.\n    (it is valid to serve, say, Array data via ajax).\n*/\n/*  Contains functions which do the grunt work of converting data to the required nested Object format.\n\n    All functions have the following input/output definitions:\n        Inputs: config - An object containing properties needed by the particular data conversion function used.\n\n        Outputs: A Promise which resolves containing the nested Object format, or rejects with an error message.\n*/\n\n// TODO service workerify this stuff\n\nfunction convertString(data, config) {\n    return new Promise(function (resolve, reject) {\n        Utils.fetchAjax(data).then(function (data) {\n            resolve(data);\n        }).catch(function (error) {\n            reject(error);\n        });\n    });\n}\n\n/*  Converts the data from an array of objects into a nensted Object format.\n*/\nfunction convertArray(data, config) {\n    var parentAttr = config.parentAttr,\n        nodeIdAttr = config.nodeIdAttr,\n        childrenAttr = config.childrenAttr;\n\n    return new Promise(function (resolve, reject) {\n        // Ensure that each object given has a `parentAttr` and `nodeIdAttr` property.\n        for (var i = 0; i < data.length; i++) {\n            if (!obj.hasOwnProperty(parentAttr) || !obj.hasOwnProperty(nodeIdAttr)) {\n                reject(\"Given object did not contain a \\\"\" + parentAttr + \"\\\" or \\\"\" + nodeIdAttr + \"\\\" property: \" + obj);\n                return;\n            }\n        }\n\n        // Ensure that exactly one node has a null parent property (ie, our root)\n        var root = data.filter(function (obj) {\n            return obj[parentAttr] === null;\n        });\n        if (root.length !== 1) {\n            reject(\"Exactly one object must have a \\\"\" + parentAttr + \"\\\" property set to null (the root of the tree).\\n                    Instead, got: \" + JSON.stringify(root));\n            return;\n        }\n        root = root[0];\n\n        // A map which will let us look up objects that have a certain parent, allowing us to construct the tree top-down.\n        var parentMap = new Map();\n        data.forEach(function (obj) {\n            if (!parentMap.has(obj[nodeIdAttr])) {\n                parentMap.set(obj[nodeIdAttr], []);\n            }\n            parentMap[obj[nodeIdAttr]].push(obj);\n        });\n\n        function populateSubtree(subtreeRoot) {\n            // Set a new parameter to store the children on this node in\n            subtreeRoot[childrenAttr] = [];\n\n            // Get children who have this subtree root as a parent\n            if (parentMap.has(subtreeRoot[nodeIdAttr])) {\n                parentMap.get(subtreeRoot[nodeIdAttr]).forEach(function (child) {\n                    subtreeRoot[childrenAttr].push(child);\n                    populateSubtree(child);\n                });\n            }\n        }\n\n        populateSubtree(root);\n\n        resolve(root);\n    });\n}\n\n/*  Validates that the data is in the correct nested object format.\n*/\nfunction convertObject(data, config) {\n    return new Promise(function (resolve, reject) {\n        var childrenAttr = config.childrenAttr;\n\n        function checkSubtree(subtreeRoot) {\n            var errorMessage = null;\n            if (!subtreeRoot.hasOwnProperty(childrenAttr)) {\n                errorMessage = \"Invalid node given, missing \\\"\" + childrenAttr + \"\\\" property: \" + JSON.stringify(subtreeRoot);\n            } else if (!Array.isArray(subtreeRoot[childrenAttr]) && subtreeRoot[childrenAttr] !== null) {\n                errorMessage = \"Invalid node given, \\\"\" + childrenAttr + \"\\\" property must point to an Array or null.\";\n            }\n\n            // Record the children in the \n            subtreeRoot[childrenAttr] = subtreeRoot[childrenAttr];\n\n            if (errorMessage) {\n                reject(errorMessage);\n                return false;\n            }\n\n            return (subtreeRoot[childrenAttr] !== null ? subtreeRoot[childrenAttr] : []).every(checkSubtree);\n        }\n\n        if (checkSubtree(data)) {\n            resolve(data);\n        }\n    });\n}\n\nexports.default = convertData;\n\n//# sourceURL=webpack:///./src/data_convert.js?");

/***/ }),

/***/ "./src/orgzchart.js":
/*!**************************!*\
  !*** ./src/orgzchart.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! promise-polyfill/src/polyfill */ \"./node_modules/promise-polyfill/src/polyfill.js\");\n\nvar _orgztree = __webpack_require__(/*! ./orgztree.js */ \"./src/orgztree.js\");\n\nvar _orgztree2 = _interopRequireDefault(_orgztree);\n\nvar _render = __webpack_require__(/*! ./render.js */ \"./src/render.js\");\n\nvar _render2 = _interopRequireDefault(_render);\n\nvar _data_convert = __webpack_require__(/*! ./data_convert.js */ \"./src/data_convert.js\");\n\nvar _data_convert2 = _interopRequireDefault(_data_convert);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*  Initializes a new OrgzChart instance.\n\n    OrgzChart accepts data in several formats:\n        1. Nested Objects:\n           Inputs in config:\n                data - (Required) An object representing the root of the tree, with child elements being contained\n                       in an array by the name given by `childrenAttrName`.\n                childrenAttr - (Optional, Default: \"children\").  A string containing the name of the attribute\n                                   to read child nodes from.\n\n        2. Array of objects:\n            Inputs in config:\n                data - (Required) An array containing objects where each object represents a node in the orgchart\n                       and having the following attributes:\n                       `parentAttrname` and `nodeIdAttr` (default \"parent\" and \"id\") which are described below.\n                parentAttr - (Optional, Default: \"parent\").  A string containing the name of the attribute which\n                             maps to the node's parent's `nodeIdAttr` attribute.  The root node should have this set\n                             to null.\n                nodeIdAttr - (Optional, Default: \"id\").  A string containing a unique identifier for a node, used\n                             to map child nodes to parents.\n\n        3. String:\n            Inputs in config:\n                data - (Required) A string which maps to a URL to load the data from.  What is returned should be\n\n    Inputs: $container - A dom element (typically div) to initialize the chart within.\n            data       - The data to initialize the OrgzChart with (See above).\n            config     - An object containing optional configuration directives: {\n                width - TODO\n                height - TODO\n                childrenAttr, parentAttr, nodeIdAttr - See above.\n                createNode - A function which when passed an object containing the data for the node to create, returns\n                             an HTMLElement to render within the orgzchart.\n                    The default createNode function expects the following attributes to be present in each data object:\n                        name - A string containing the name of the attribute on the object \n                        title - A string containing the position title of the user identified by the object\n            }\n    }\n*/\n\nwindow.OrgzChart = function ($container, data, config) {\n    var $svg, root;\n\n    this.layout = function () {\n        root.layout();\n        //$svg.size(root.elements.$container.bbox().width, root.elements.$container.bbox().height); // TODO\n    }.bind(this);\n\n    function init() {\n        var _this = this;\n\n        if (!($container instanceof Element)) {\n            throw 'First parameter to OrgzChart must be a DOM element.  Got ' + $container + ' instead';\n        }\n\n        $svg = SVG($container).size(8000, 300); // TODO sizes\n\n        config = _makeInternalConfig(config);\n\n        (0, _data_convert2.default)(data, config).then(function (data) {\n            root = new _orgztree2.default($svg, data, config);\n            _this.layout();\n        }).catch(function (error) {\n            console.error(error);\n        });\n    }\n\n    function _makeInternalConfig(config) {\n        return {\n            childrenAttr: config.childrenAttr || \"children\",\n            parentAttr: config.parentAttr || \"parent\",\n            nodeIdAttr: config.nodeIdAttr || \"id\",\n            createNode: config.createNode || _defaultCreateNode,\n            subTreeIdGen: function () {\n                var idx = 0;\n                this.next = function () {\n                    return idx++;\n                };\n                return this;\n            }.apply({}),\n            subTreeMap: new Map()\n        };\n    }\n\n    function _defaultCreateNode(nodeData) {\n        var $nodeContainer = document.createElement(\"div\"),\n            $nameContainer = document.createElement(\"div\"),\n            $titleContainer = document.createElement(\"div\");\n\n        $nodeContainer.appendChild($nameContainer);\n        $nodeContainer.appendChild($titleContainer);\n        $nodeContainer.className = \"node\";\n        $nameContainer.innerHTML = nodeData[\"name\"] || \"\";\n        $titleContainer.innerHTML = nodeData[\"title\"] || \"\";\n\n        return $nodeContainer;\n    }\n\n    init.call(this);\n    return this;\n}.bind({});\n\n//# sourceURL=webpack:///./src/orgzchart.js?");

/***/ }),

/***/ "./src/orgztree.js":
/*!*************************!*\
  !*** ./src/orgztree.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar OrgzSubTree = function ($parent, datum, config) {\n    this.treeId = config.subTreeIdGen.next();\n    this.datum = datum; // TODO\n    config.subTreeMap.set(this.treeId, this);\n\n    var children = [],\n        elements;\n\n    /*  Returns an array containing the child subtrees which are children of this subtree.\n     */\n    this.getChildren = function () {\n        return children.slice();\n    }.bind(this);\n\n    /*  Returns the root node DOM element for this subtree.\n     */\n    this.getRoot = function () {\n        return elements.$root;\n    };\n\n    this.layout = function () {\n        var rootDimensions = _getRootDimensions();\n\n        // Layout each of our child trees\n        children.forEach(function (tree) {\n            return tree.layout();\n        });\n\n        // Position the children trees below the root\n        elements.$childrenContainer.y(rootDimensions.height + 5); // TODO config this offset\n\n        // Position each subtree relative to each other\n        for (var i = 1; i < children.length; i++) {\n            children[i].positionToRightOf(children[i - 1]);\n        }\n\n        // Layout/position the root\n        elements.$foreignObject.size(rootDimensions.width, rootDimensions.height);\n        elements.$rootContainer.x(elements.$container.bbox().width / 2 - rootDimensions.width / 2);\n    }.bind(this);\n\n    /*  Positions this subtree to the right of the given subtree.\n         Inputs: subTree - An instance of OrgzSubTree to position ourselves adjacent to.\n     */\n    this.positionToRightOf = function (subTree) {\n        console.log(\"left\", subTree.datum.name, \"right\", this.datum.name);\n        // Find the righternmost child of the given subtree and the lefternmost child of this subtree\n        // to the furthest shared level\n        var currentLeft,\n            nextLeft = subTree,\n            currentRight,\n            nextRight = this;\n        do {\n            currentLeft = nextLeft;\n            nextLeft = currentLeft.getChildren().slice(-1)[0];\n            currentRight = nextRight;\n            nextRight = currentRight.getChildren().slice(0)[0];\n        } while (nextLeft !== undefined && nextRight !== undefined);\n\n        var rightMostLeftChild = currentLeft.getRoot(),\n            leftMostRightChild = currentRight.getRoot();\n\n        // Calculate the offset for this subTree that prevents overlapping\n        var rightRect = rightMostLeftChild.getBoundingClientRect(),\n            rightX = rightRect.x + rightRect.width;\n        elements.$container.x(rightX + 5);\n    }.bind(this);\n\n    function _init() {\n        // Initialize the various components for this subtree\n        var $container = $parent.group(),\n            $rootContainer = $container.group(),\n            $childrenContainer = $container.group(),\n            $foreignObject = $rootContainer.foreignObject(),\n            $root = config.createNode(datum);\n\n        $foreignObject.appendChild($root);\n        $container.addClass(\"subtree-container\");\n        $rootContainer.addClass(\"root-container\");\n        $childrenContainer.addClass(\"children-container\");\n        $foreignObject.addClass(\"element-container\");\n\n        elements = {\n            $container: $container,\n            $rootContainer: $rootContainer,\n            $root: $root,\n            $foreignObject: $foreignObject,\n            $childrenContainer: $childrenContainer\n        };\n\n        // Initialize our children subtrees\n        for (var i = 0; i < datum.children.length; i++) {\n            children.push(new OrgzSubTree(elements.$childrenContainer, datum.children[i], config));\n        }\n    }\n\n    function _getRootDimensions() {\n        // Enlarge the container elements dimensions to ludicrus proportions\n        var original = {\n            parentHeight: elements.$rootContainer.height(),\n            parentWidth: elements.$rootContainer.width()\n        };\n        elements.$rootContainer.height(5000);\n        elements.$rootContainer.width(5000);\n\n        // Get dimensions of the (hopefully) unconstrained root\n        var width = elements.$root.offsetWidth,\n            height = elements.$root.offsetHeight;\n\n        // Revert parent dimensions\n        elements.$rootContainer.height(original.parentHeight);\n        elements.$rootContainer.width(original.parentWidth);\n\n        return { width: width, height: height };\n    }\n\n    _init.call(this);\n    return this;\n}.bind({});\n\nexports.default = OrgzSubTree;\n\n//# sourceURL=webpack:///./src/orgztree.js?");

/***/ }),

/***/ "./src/render.js":
/*!***********************!*\
  !*** ./src/render.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Renderer = function () {\n    function Renderer($container, orgztree, data) {\n        _classCallCheck(this, Renderer);\n\n        this.$container = $container;\n        this.orgztree = orgztree;\n        this.lastrendered = {};\n\n        this.scale = 1;\n        this.translate = {\n            x: 0,\n            y: 0\n        };\n    }\n\n    _createClass(Renderer, [{\n        key: \"render\",\n        value: function render() {\n            this.drawSubtree(this.orgztree.root);\n        }\n    }, {\n        key: \"drawSubtree\",\n        value: function drawSubtree($parentG, subtree) {\n            var $newG = $parentG.group(),\n                $root = $;\n            $node = $parentG.foreignObject(), children = this.orgztree.children(subtree);\n\n            for (var i = 0; i < children.length; i++) {\n                this.drawSubtree(children[i]);\n            }\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(_scale) {\n            this.scale = _scale;\n            this._setTransform();\n        }\n    }, {\n        key: \"pan\",\n        value: function pan(x, y) {\n            this.translate.x = x;\n            this.translate.y = y;\n            this._setTransform();\n        }\n    }, {\n        key: \"getNodeDimensions\",\n        value: function getNodeDimensions($node) {\n            // Display the element whilst invisible to determine its size\n            var original = {\n                display: $node.style.display,\n                visibility: $node.style.visibility,\n                position: $node.style.position\n            };\n            $node.position = \"absolute\";\n            $node.visibility = \"hidden\";\n            $node.display = \"block\";\n            this.$container.parentNode.insertBefore($node, this.$container);;\n\n            // Get dimensions\n            var width = $node.offsetWidth,\n                height = $node.offsetHeight;\n\n            // Remove from DOM, Revert styles\n            $node.parentNode.removeChild($node);\n            $node.display = original.display;\n            $node.visibility = original.visibility;\n            $node.position = original.position;\n\n            return { width: width, height: height };\n        }\n    }, {\n        key: \"_setTransform\",\n        value: function _setTransform() {\n            var scale = \"scale(\" + this.scale + \")\",\n                translateX = this.translate.x + \"px\",\n                translateY = this.translate.y + \"px\",\n                translate = \"translate(\" + translateX + \", \" + translateY + \")\";\n\n            this.svg.node.style.transform = scale + \" \" + translate;\n        }\n    }]);\n\n    return Renderer;\n}();\n\nexports.default = Renderer;\n\n//# sourceURL=webpack:///./src/render.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fetchAjax = undefined;\n\nvar _promisePolyfill = __webpack_require__(/*! promise-polyfill */ \"./node_modules/promise-polyfill/src/index.js\");\n\nvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction fetchAjax(url) {\n    return new _promisePolyfill2.default(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url);\n        xhr.onload = function () {\n            try {\n                resolve(JSON.parse(xhr.responseText));\n            } catch (exc) {\n                reject(exc);\n            }\n        };\n        xhr.onerror = function () {\n            reject(xhr.statusText);\n        };\n\n        xhr.send();\n    });\n}\n\nexports.fetchAjax = fetchAjax;\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ });